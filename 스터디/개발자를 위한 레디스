
# 레디스

1. 레디스를 캐시 및 세션 스토어로 활용하고, 메시지 브로커로 사용하는 방법
    - 레디스도 서비스간 메시지를 전할 때 매우 유용하게 사용할 수 있다. (pub/sub)
    - fire-and-forget 패턴이 필요한 간단한 알림 서비스에서는 유용하게 사용할 수 있다.
    - 레디스의 List 자료 구조를 통해 데이터가 들어오면 읽어 갈 수 있는 블로킹 기능을 제공한다. 또는 아파치 카프카에 영감을 받아 만들어진 stream 자료 구조도 있다.
    - [레디스 분산 락 Spin Lock과 pub/sub 중 성능이 더 좋은 것은?](https://www.linkedin.com/feed/update/urn:li:activity:7300495152970612736?updateEntityUrn=urn%3Ali%3Afs_updateV2%3A%28urn%3Ali%3Aactivity%3A7300495152970612736%2CFEED_DETAIL%2CEMPTY%2CDEFAULT%2Cfalse%29)
2. NoSQL 데이터 유형
    - 그래프 유형
    - 로우, 컬럼 유형
    - 문서 유형 : JSON
    - 키-값 유형
3. 레디스는 메인 스레드 1개와 별도의 스레드 3개, 총 4개의 스레드로 동작한다.
    - 클라이언트의 커맨드는 1개의 스레드로 처리하니 반환이 느린 특정 커맨드를 주의해서 사용해야한다. (KEYS
4. 레디스의 데이터는 AOF, RDB 형식으로 디스크에 주기적으로 저장할 수 있다.
5. 페이지의 크기를 자동으로 관리하는 THP 기능은 비활성화 하는 것이 좋다
6. 레디스에서 지원하는 자료구조
    - string : 가장 간단한 자료구조, 최대 512MB, 문자열이 binary-safe하게 처리되기 때문에 이미지와 같은 바이트 값, HTTP 응답 값 등의 다양한 데이터를 저장하는 것도 가능하다.
       - bitmap : string 자료구조에 bit 연산을 수행할 수 있도록 확장한 형태
    - list : deque와 비슷한 커맨드를 지원한다
    - hash : 하나의 hash 자료구조 내에서 필드-값 쌍을 가진 아이템의 집합, 하나의 hash 내에서 유일함, 객체를 표현하기 적절한 자료구조이기 때문에 관계형 데이터베이스의 테이블 데이터로 변환하는 것도 간편하다.
    - set : 교집합, 합집합, 차집합 등의 집한 연산 커맨드를 제공
    - sorted-set : score 값에 따라 정렬되는 고유한 문자열의 집합, 모든 아이템은 스코어-값 쌍을 가진다. 인덱스로 접근할 일이 많은 경우 List보다 빠르다. O(log(n))으로 처리됨. 그럼 삽입하거나 삭제할 때 정렬 연산이 포함될 것 같긴함
    - hyperloglog : 집합의 원소 개수인 카디널리티를 측정할 수 있는 자료구조
    - geospatial : 경도, 위도 데이터 쌍의 집합, 내부적으로 sorted-set으로 저장되며, 하나의 자료 구조 안에 키는 중복 저장되지 않는다. (BYRADIUS, BYBOX...)
    - stream : 카프카의 소비자 그룹 개념을 도입해 데이터를 분산 처리할 수 있음, 데이터를 계속해서 추가하는 방식(append-only)으로 저장되므로, 실시간 이벤트 혹은 로그성 데이터의 저장을 위해 사용할 수도 있다.
7. **보통 키 하나당 저장하는 아이템은 최대 200~300만 개까지로 조정할 것을 권장한다.**
8. 사용 사례
    - sorted set : 실시간 리더보드, 최근 검색 기록, 태그 기능
    - set : 좋아요 기능
    - hash : 읽지 않은 메시지 수 카운팅하기, 세션 스토어
    - bitmap : DAU 구하기
    - 랜덤 데이터 추출 (중복 허용 선택 가능)
9. 캐시 워밍
10. 쓰기 전략
    - write through : RDB 데이터가 수정될 때 레디스에 직접 캐시 (만료 시간 설정 필수)
    - cache invalidation : RDB 데이터가 수정될 때 레디스 캐시 데이터 삭제
    - write behind (write back) : 쓰기가 빈번하게 발생하는 환경이라면 캐시에 먼저 업데이트하고 건수나 특정 시간 간격에 따라 비동기적으로 RDB에 업데이트
11. 키 삭제 방식
    - passive 방식 : 키가 만료되었다면 클라이언트가 접근할 때 삭제된다
    - active 방식 : TTL값이 있는 키 중 20개를 랜덤하게 뽑아낸 뒤, 만료된 키를 모두 메모리에서 삭제한다. 만약 25% 이상의 키가 삭제됐다면 다시 20개의 키를 랜덤하게 뽑은 뒤 확인하고, 아니라면 뽑아놓은 20개의 키 집합에서 다시 확인한다. 이러한 과정을 1초에 10번씩 수행한다
12. 메모리 관리와 maxmemory-policy 설정
    - **noeviction** (default) : 메모리가 가득 차더라도 임의로 데이터를 삭제하지 않고 더 이상 저장할 수 없다는 에러를 반환한다.
    - **LRU eviction** : 가장 최근에 사용되지 않은 데이터부터 삭제하는 정책
        - volatile-lru : EXPIRE가 설정돼 있는 키에 한해서 LRU 방식으로 키를 삭제한다. 만료 시간이 설정되어 있다는 것은 언젠가 삭제될 것이기 때문에 가장 오래된 키부터 삭제한다. **임의적인 방식으로 삭제되면 안되는 값에 대해서는 만료 시간을 지정하지 않는다면 이 방법이 적합할 수 있음**
        - allkeys-lru : 모든 키에 대해 LRU 알고리즘을 적용하며 권장되는 방식이다.
    - **LFU eviction** : 가장 자주 사용되지 않은 데이터부터 삭제하는 정책
        - volatile-lfu : EXPIRE가 설정돼 있는 키에 한해서 LFU 방식으로 키를 삭제한다.
        - allkeys-lfu : 모든 키에 대해서 LFU 알고리즘을 적용한다.
    - **Random eviction** : 삭제될 키 값을 계산하지 않고 랜덤으로 하나 골라 삭제한다. 권장하지 않는다.
    - **volatile-ttl** : 만료 시간이 가장 작은 키를 삭제한다.
13. 캐시 스탬피드 현상
    - look aside 읽기 방식에서 캐시 미스가 발생하였을 때 RDB에서 '중복 읽기'와 캐시 '중복 쓰기'가 발생하는 현상을 말한다.
    - **적절한 만료시간 설정** : 너무 짧지 않게 설정
    - **선 계산** : 캐시 히트가 발생하였을 때 랜덤으로 키의 만료시간을 갱신한다.
    - **PER 알고리즘**

# 무지목록
