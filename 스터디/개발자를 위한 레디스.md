# 레디스 5장까지

1. 레디스를 캐시 및 세션 스토어로 활용하고, 메시지 브로커로 사용하는 방법
    - 레디스도 서비스간 메시지를 전할 때 매우 유용하게 사용할 수 있다. (pub/sub)
    - fire-and-forget 패턴이 필요한 간단한 알림 서비스에서는 유용하게 사용할 수 있다.
    - 레디스의 List 자료 구조를 통해 데이터가 들어오면 읽어 갈 수 있는 블로킹 기능을 제공한다. 또는 아파치 카프카에 영감을 받아 만들어진 stream 자료 구조도 있다.
    - [레디스 분산 락 Spin Lock과 pub/sub 중 성능이 더 좋은 것은?](https://www.linkedin.com/feed/update/urn:li:activity:7300495152970612736?updateEntityUrn=urn%3Ali%3Afs_updateV2%3A%28urn%3Ali%3Aactivity%3A7300495152970612736%2CFEED_DETAIL%2CEMPTY%2CDEFAULT%2Cfalse%29)
2. NoSQL 데이터 유형
    - 그래프 유형
    - 로우, 컬럼 유형
    - 문서 유형 : JSON
    - 키-값 유형
3. 레디스는 메인 스레드 1개와 별도의 스레드 3개, 총 4개의 스레드로 동작한다.
    - 클라이언트의 커맨드는 1개의 스레드로 처리하니 반환이 느린 특정 커맨드를 주의해서 사용해야한다. (KEYS
4. 레디스의 데이터는 AOF, RDB 형식으로 디스크에 주기적으로 저장할 수 있다.
5. 페이지의 크기를 자동으로 관리하는 THP 기능은 비활성화 하는 것이 좋다
6. 레디스에서 지원하는 자료구조
    - string : 가장 간단한 자료구조, 최대 512MB, 문자열이 binary-safe하게 처리되기 때문에 이미지와 같은 바이트 값, HTTP 응답 값 등의 다양한 데이터를 저장하는 것도 가능하다.
       - bitmap : string 자료구조에 bit 연산을 수행할 수 있도록 확장한 형태
    - list : deque와 비슷한 커맨드를 지원한다
    - hash : 하나의 hash 자료구조 내에서 필드-값 쌍을 가진 아이템의 집합, 하나의 hash 내에서 유일함, 객체를 표현하기 적절한 자료구조이기 때문에 관계형 데이터베이스의 테이블 데이터로 변환하는 것도 간편하다.
    - set : 교집합, 합집합, 차집합 등의 집한 연산 커맨드를 제공
    - sorted-set : score 값에 따라 정렬되는 고유한 문자열의 집합, 모든 아이템은 스코어-값 쌍을 가진다. 인덱스로 접근할 일이 많은 경우 List보다 빠르다. O(log(n))으로 처리됨. 그럼 삽입하거나 삭제할 때 정렬 연산이 포함될 것 같긴함
    - hyperloglog : 집합의 원소 개수인 카디널리티를 측정할 수 있는 자료구조
    - geospatial : 경도, 위도 데이터 쌍의 집합, 내부적으로 sorted-set으로 저장되며, 하나의 자료 구조 안에 키는 중복 저장되지 않는다. (BYRADIUS, BYBOX...)
    - stream : 카프카의 소비자 그룹 개념을 도입해 데이터를 분산 처리할 수 있음, 데이터를 계속해서 추가하는 방식(append-only)으로 저장되므로, 실시간 이벤트 혹은 로그성 데이터의 저장을 위해 사용할 수도 있다.
7. **보통 키 하나당 저장하는 아이템은 최대 200~300만 개까지로 조정할 것을 권장한다.**
8. 사용 사례
    - sorted set : 실시간 리더보드, 최근 검색 기록, 태그 기능
    - set : 좋아요 기능
    - hash : 읽지 않은 메시지 수 카운팅하기, 세션 스토어
    - bitmap : DAU 구하기
    - 랜덤 데이터 추출 (중복 허용 선택 가능)
9. 캐시 워밍
10. 쓰기 전략
    - write through : RDB 데이터가 수정될 때 레디스에 직접 캐시 (만료 시간 설정 필수)
    - cache invalidation : RDB 데이터가 수정될 때 레디스 캐시 데이터 삭제
    - write behind (write back) : 쓰기가 빈번하게 발생하는 환경이라면 캐시에 먼저 업데이트하고 건수나 특정 시간 간격에 따라 비동기적으로 RDB에 업데이트
11. 키 삭제 방식
    - passive 방식 : 키가 만료되었다면 클라이언트가 접근할 때 삭제된다
    - active 방식 : TTL값이 있는 키 중 20개를 랜덤하게 뽑아낸 뒤, 만료된 키를 모두 메모리에서 삭제한다. 만약 25% 이상의 키가 삭제됐다면 다시 20개의 키를 랜덤하게 뽑은 뒤 확인하고, 아니라면 뽑아놓은 20개의 키 집합에서 다시 확인한다. 이러한 과정을 1초에 10번씩 수행한다
12. 메모리 관리와 maxmemory-policy 설정
    - **noeviction** (default) : 메모리가 가득 차더라도 임의로 데이터를 삭제하지 않고 더 이상 저장할 수 없다는 에러를 반환한다.
    - **LRU eviction** : 가장 최근에 사용되지 않은 데이터부터 삭제하는 정책
        - volatile-lru : EXPIRE가 설정돼 있는 키에 한해서 LRU 방식으로 키를 삭제한다. 만료 시간이 설정되어 있다는 것은 언젠가 삭제될 것이기 때문에 가장 오래된 키부터 삭제한다. **임의적인 방식으로 삭제되면 안되는 값에 대해서는 만료 시간을 지정하지 않는다면 이 방법이 적합할 수 있음**
        - allkeys-lru : 모든 키에 대해 LRU 알고리즘을 적용하며 권장되는 방식이다.
    - **LFU eviction** : 가장 자주 사용되지 않은 데이터부터 삭제하는 정책
        - volatile-lfu : EXPIRE가 설정돼 있는 키에 한해서 LFU 방식으로 키를 삭제한다.
        - allkeys-lfu : 모든 키에 대해서 LFU 알고리즘을 적용한다.
    - **Random eviction** : 삭제될 키 값을 계산하지 않고 랜덤으로 하나 골라 삭제한다. 권장하지 않는다.
    - **volatile-ttl** : 만료 시간이 가장 작은 키를 삭제한다.
13. 캐시 스탬피드 현상
    - look aside 읽기 방식에서 캐시 미스가 발생하였을 때 RDB에서 '중복 읽기'와 캐시 '중복 쓰기'가 발생하는 현상을 말한다.
    - **적절한 만료시간 설정** : 너무 짧지 않게 설정
    - **선 계산** : 캐시 히트가 발생하였을 때 랜덤으로 키의 만료시간을 갱신한다.
    - **PER 알고리즘**

# 레디스 끝까지

1. **메시지 브로커의 핵심** : 통신이 불가능한 상황이 바로 장애로 이어지지 않게, 메시지 버퍼 역할인 채널을 만듦. 가능한 비동기 통신을 사용하는 것
    - 메시징 큐 : 큐에 각각 데이터를 푸시해야함. 소비자가 데이터를 읽어가면 큐에서 데이터를 삭제함. 1:1 상황에서 유리함.
        - **레디스의 pub/sub** : `fire-and-forget` 패턴이 필요한 간단한 알림 서비스에서는 유용할 수 있다. (로깅, 이벤트 발행, 통계 데이터 수집 등)    
    - 이벤트 스트림 : 특정 저장소에 메시지를 보내고 소비자가 pull 해감. 소비자가 읽어가도 바로 삭제하지 않고 특정 기간동안 저장될 수 있음. N:N 상황에서 유리함 (ex 코틀린의 Flow)
        - **레디스의 stream** : 소비지와 소비자 그룹이라는 개념을 이용하면 카프카에서와 비슷하게 데이터의 분산 처리 가능. 실시간 소비 또는 시간대별로 검색 가능
2. 트위터는 각 유저의 타임라인 캐시 데이터를 레디스에서 list 자료구조로 관리한다.
    - B,C가 A를 팔로우하고 있을 때 A가 글을 작성하면 B와 C의 list에 새로운 아이템으로 추가한다. RPUSHX 커맨드로 list가 존재하는 사용자에게만 푸시한다.
3. Stream
    - `append-only`
    - 대량의 데이터를 효율적으로 처리할 수 있는 플랫폼으로 활용 가능
    - 여러 생산자가 생성한 데이터를 다양한 소비자가 처리할 수 있게 지원하는 데이터 저장소 및 중간 큐잉 시스템으로 사용 가능
    - 다른 자료구조와 마찬가지로 하나의 키에 연결된 자료구조다.
    - 각 메시지는 시간과 관련된 유니크한 ID를 가지며, 이 값은 중복되지 않는다. `<milliseoncdsTime>-<sequenceNumber>`
    - 데이터는 hash 자료구조 처럼 '필드-값'쌍으로 저장된다.
    - **소비자가 실시간 리스닝**
    - **ID를 이용해 필요한 데이터를 검색**
4. **팬아웃** : 같은 데이터를 여러 소비자에게 전달하는 것
    - 레디스는 데이터가 저장될 때마다 고유한 ID를 부여받아 순서대로 공급하기에, 소비자에게 순서가 항상 보장된다. 레디스의 소비자 그룹은 다른 소비자가 읽지 않은 데이터만 읽어가도록 설정하는 것이다.
        - 하나의 소비자 그룹에서 여러 stream을 리스닝하는 것도 가능하고, 하나의 stream에서 여러 소비자 그룹이 리스닝하는 것도 가능하다.
    - 카프카는 파티션 내에서만 유니크 키가 보장되기 때문에 소비자가 여러 파티션에서 토픽을 읽어갈 때에는 데이터의 순서를 보장할 수 없다. 토픽 내의 파티션과 소비자를 일대일로 연결하기 위해 소비자 그룹을 설정하여 순서를 보장할 수 있다.
    - **카프카가 파티션이라는 개념을 이용해 소비자의 부하 분산을 관리한다면 레디스의 stream은 파티션이라는 분할 없이도 소비자 그룹이라는 개념을 이용해 여러 소비자에게 stream의 데이터를 분산시킬 수 있다는 특징을 갖고 있다.**
5. **ACK와 보 리스트**
    - 소비자에게 장애가 발생한 경우, 재처리를 위해 메시지 브로커는 각 소비자에게 어떤 메시지까지 전달했고, 전달된 메시지의 처리 유무를 인지하고 있어야 한다.
    - 레디스 stream에서는 소비자 그룹에 속한 소비자가 메시지를 읽어가면 각 소비자별로 읽어간 메시지에 대한 리스트를 새로 생성하며, 마지막으로 읽어간 데이터의 ID로 `last_delivered_id`값을 업데이트한다. 소비자가 ACK를 전송하면 이 ID 값이 증가한다.
7. `as most once` vs `as least once` vs `exactly once`

## AOF

레디스 인스턴스거 처리한 모든 write/update 연산 자체를 모두 log 파일에 기록, 복원 시에는 파일을 다시 읽어가며 데이터 세트 재구성  
rewrite를 수행하여 이전 기록은 모두 사라지고 최종 데이터만 기록시켜 파일의 크기를 줄일 수 있다. (현재 메모리 상태를 그대로 재현할 수 있는 최소한의 명령어 집합)  
디스크에 쓰는 시점 : always (성능 매우 떨어짐), everysec (1초 간격), no (OS가 정함) -> always를 사용하면 너무 느려지고, no를 사용하면 최대 30초 유실 가능하기 때문에 everysec를 권장한다.  

메모리상의 데이터가 변경되는 커맨드만 기록된다!  

**장점**  
- 원하는 시점으로 복구할 수 있다.
  
**단점**
- RDB 파일보다 크기가 크다.
- 주기적으로 압축해 재작성해야 한다.

## RDB
일정 시점에 메모리에 저장된 데이터 전체를 저장 (snapshot 방식)  
다른 원격 저장소로 파일을 옮겨 2차 백업을 수행한다면 데이터 센터 장애 등 더 큰 장애에도 대처할 수 있다.  

1. SAVE : 메인 프로세스를 블로킹하고 그 스냅샷을 저장
2. BGSAVE : 메인 프로세스를 포크떠 자식 프로세스가 백그라운드에서 디스크로 저장하도록 한다.
    - COW가 사용되어, 최악의 경우 메모리 사용량이 일시적으로 두 배까지 증가할 수 있다.

**장점**  
- AOF에 비해 사이즈가 작고 스냅샷을 다시 읽기만 하면 돼서 속도가 빠르다.  
- 시점 단위로 여러 백업본을 저장할 수 있다.
- AOF 파일보다 복원이 빠르다.

**단점**  
- 메모리가 두 배로 사용되고 백업 시점을 제외한 중간 시점에서 발생한 데이터는 유실될 수 있다.
- 저장하지 않은 특정 시점으로의 복원은 불가하다.
  
## 개선된 AOF 방식
RDB preamble + AOF tail은 **AOF 파일 하나 안에서 앞부분을 RDB 스냅샷, 뒷부분을 AOF 명령 로그로 쓰는 하이브리드 형식**이다.  

- Redis는 AOF 리라이트(BGREWRITEAOF 등)를 할 때, 새로 만드는 AOF의 **앞부분(base file)**을 “RDB 형식의 스냅샷”으로 기록하고, 그 이후 변경 사항은 기존처럼 **AOF 명령 로그(tail)**로 계속 append한다.
- 재시작 시에는 이 AOF 파일을 읽으면서 먼저 **RDB preamble을 로딩해 시점 스냅샷을 복원한 뒤, 남은 AOF tail 명령들을 순서대로 재생해 최신 상태를 만든다.**
- 즉, 고정 영역을 RDB(binary)로 저장하고 증분 영역을 AOF(RESP)로 저장한다. 이 경우 fork를 이용해 자식 프로세스를 생성하기 때문에 메모리 사용량을 유의해야 한다.
  
**왜 이렇게 하는가?**  
- RDB 형식은 명령 로그보다 **더 compact하고 로딩 속도가 빠르기 때문에**, AOF 전체를 순수 명령 로그로 유지하는 것보다 **재시작 시간이 단축되고 디스크 사용량도 줄어든다.**
- 반대로 tail 부분은 여전히 커맨드 단위로 append되기 때문에, **스냅샷 이후의 변경에 대해서는 AOF 특유의 높은 내구성(append-only)을 유지**할 수 있다.

## 복제와 AOF의 역할 차이

“마스터+레플리카로 고가용성은 확보했지만, AOF가 완전 불필요하다”라고 단정하기는 어렵고, "무엇을 얼마나 잃어도 되는지"에 따라 달라집니다.
- 레플리케이션은 주로 “고가용성(HA)”과 장애 시 빠른 서비스 복구를 위한 기능입니다. 마스터 장애 시 레플리카 승격으로 다운타임을 줄이지만, 네트워크 단절·지연 등으로 인해 일부 쓰기 손실이나 레플리카 간 데이터 차이는 발생할 수 있습니다.
- AOF/RDB 같은 퍼시스턴스는 “디스크에 데이터를 얼마나 잘 남겨두느냐(내구성, Durability)”를 다룹니다. AOF는 모든 쓰기 명령을 로그로 남겨 거의 실시간에 가까운 복구가 가능하고, RDB는 시점 스냅샷이라 그 사이 구간의 데이터는 잃을 수 있습니다.

## 언제 AOF 없이도 충분한가

다음 조건이면 AOF 없이 “복제 + 주기적 RDB 스냅샷” 정도로도 실무에서 많이 운용합니다.

- Valkey를 사실상 “캐시”로 쓰고 있고, 몇 분~몇십 분 수준의 데이터 유실을 감내할 수 있을 때.  
- 장애 시 “원천 DB나 외부 시스템에서 다시 채울 수 있다”는 보장이 있을 때.  
- 쓰기 QPS가 높고 디스크 I/O 오버헤드(AOF fsync 등)를 최소화하고 싶을 때.  

이 경우:
- Multi-AZ 레플리카 + 자동 장애조치로 가용성 확보.  
- RDB 스냅샷은 재해 복구(완전 장애, 리전 사고 등)용으로만 사용.  

## AOF를 고려해야 하는 상황

반대로, 아래에 가깝다면 AOF를 검토하는 것이 좋습니다.

- Valkey의 데이터가 “원천 데이터”에 가깝고, 몇 초 이내의 쓰기라도 잃기 어렵다.  
- 마스터와 레플리카 모두 동시에 날아간 상황(잘못된 운영, 리전 장애 등)에서도 최대한 최근 상태로 복구해야 한다.  
- 장애 후에도 데이터 정합성이 비즈니스적으로 매우 중요하다.  

정리하면,  
- “클러스터 모드 아님 + 마스터/레플리카 구성”만으로는 HA는 확보되지만, 강한 내구성까지 보장되는 것은 아닙니다.
- Valkey를 캐시로 쓰고 데이터 유실 허용이면 AOF는 굳이 필요 없고, 반대로 Valkey 데이터 자체가 중요하면 레플리케이션과 별개로 AOF(또는 AOF+RDB)를 보는 게 안전합니다.

## 복제 메커니즘

### **복제**
- 마스터 노드의 데이터를 복제본 노드로 실시간 복사하는 기능. 마스터에 장애가 발생하는 경우 데이터가 유실된다 해도 복제본 노드에서 데이터를 확인할 수 있다.
- 마스터의 장애를 감지해 레디스로 들어오는 클라이언트 연결을 자동으로 복제본 노드로 리다이렉션하는 기능으로 자동 페일오버가 가능하다.
- 한 개의 복제 그룹에서는 항상 한 개의 마스터 노드만 존재한다.

> 1. 읽기 노드에서 REPLICAOF 커맨드로 복제 연결을 시도한다.
> 2. 마스터 노드에서는 fork로 자식 프로세스를 새로 만든 뒤 RDB 스냅숏을 생성한다.
> 3. 2번 과정 동안 마스터 노드에서 수행된 모든 데이터셋 변경 작업은 레디스 프로토콜 형태로 마스터의 복제 버퍼에 저장된다.
> 4. RDB 파일이 생성 완료되면 파일은 복제본 노드로 복사된다.
> 5. 읽기 노드의 데이터를 모두 삭제하고 RDB 파일을 이용해 데이터를 로딩한다.
> 6. 복제 과정동안 버퍼링 됐던 복제버퍼의 데이터를 복제본으로 전달해 수행시킨다.

`repl-diskless-sync`는 **마스터→레플리카 RDB 전송 방식**을, `repl-diskless-load`는 **레플리카가 받은 RDB를 어떻게 로드할지**를 제어하는 옵션이다.[1]

### repl-diskless-sync

- 의미: 풀 싱크 시 마스터가 RDB를 **디스크에 쓴 뒤 파일을 레플리카에 보내는지(디스크 백업)**, 아니면 **디스크를 거치지 않고 소켓으로 바로 스트리밍할지(디스크리스)**를 결정한다.
- 동작 모드:  
  - `no` → 디스크 백업 방식, 자식 프로세스가 RDB를 디스크에 쓰고, 부모가 그 파일을 여러 레플리카에게 전송.
  - `yes` → 디스크리스 방식, 자식 프로세스가 RDB를 레플리카 소켓에 직접 쏴준다; 디스크 I/O는 줄지만, 한 번 전송이 시작되면 새로 붙은 레플리카는 다음 라운드를 기다려야 한다.
- 기본값: 예시 `redis.conf`에서는 `repl-diskless-sync yes`로 설정되어 있다.

### repl-diskless-load

- 의미: 레플리카가 마스터에서 RDB를 받을 때, 그 RDB를 **디스크에 저장했다가 로드할지**, 아니면 **소켓에서 들어오는 스트림을 바로 파싱해 메모리로 로드할지**를 제어한다.
- 옵션 값:  
  - `disabled` → 디스크리스 로드를 사용하지 않는다. RDB를 파일로 저장한 후 그 파일을 다시 읽어 로드한다.
  - `swapdb` → 소켓에서 직접 파싱하면서 기존 DB는 유지한 채 새 데이터셋을 별도 공간에 로드한 뒤 마지막에 스왑한다. 복제 중에도 기존 데이터로 서비스 가능하지만, 전체 데이터 2벌이 필요해 메모리 요구가 크다.
  - `on-empty-db` → 현재 DB가 비어 있을 때만 디스크리스 로드를 사용한다. 기존/신규 데이터가 동시에 메모리에 공존하지 않아 메모리 측면에서 더 안전하다.
- 기본값: `repl-diskless-load disabled`가 기본 설정이다.[1]

## **센티널**

9. 센티널
    - 자동 페일오버와 인스턴스 구성 정보 안내를 통해 마스터에 장애가 발생하더라도 다운타임을 최소화해준다.
    - 쿼럼을 기준으로 승격할 마스터를 정하기 때문에 홀수의 서버가 필요하지만 최소한으로 2대의 정상적인 서버, 센티넬과 1대의 센티넬만 구성하여 운영할 수도 있다.
    - 일시적인 네트워크 단절로 인한 두 개의 마스터가 생성될 수 있디. (스플릿 브레인 문제)
10. 클러스터
    - 각각 최소 3대의 마스터, 복제본 노드
    - 각 노드들은 풀 메쉬 토폴로지 형태로 구성되어 있으며, 모든 노드는 N-1개의 다른 노드와 송수신 TCP 연결이 되어 있다.
    - 서로 다른 해시슬롯에 속한 키에 대해서는 다중 키 커맨드를 사용할 수 없지만 해시태그를 이용해서 처리할 수 있다.
11. 클라이언트
    - 멀티플렉싱 방식을 사용하기에 하나의 통신 채널을 통해 여러 데이터 스트림을 전송할 수 있다.
    - 하나의 스레드에서 여러 소켓을 감시하고, 소켓 이벤트가 발생하는지 지속적으로 확인할 수 있기 때문에 다중 클라이언트 지원을 가능하게하고, 많은 클라이언트 요청을 동시에 처리하는데 블로킹 문제를 피할 수 있다.
      일반 클라이언트, pub/sub 클라이언트, 복제본을 위한 출력 버퍼 크기가 모두 다르게 적용된다.
    - **파이프라이닝**
        - 클라이언트가 연속적으로 여러 개의 커맨드를 레디스 서버에 보낼 수 있도록 하는 기능
    - **클라이언트 사이드 캐싱**

# 읽기 노드 복제 프로토콜

- Redis 복제 공식 문서에 따르면, 새 레플리카가 붙거나 부분 동기화가 불가능한 경우에는 **마스터가 RDB 스냅샷을 생성해서 레플리카로 전송하고, 레플리카는 그 RDB를 메모리에 로드한 뒤 그 이후 변경은 replication stream으로 받는다.**
- 이 과정은 **마스터의 persistence 설정(RDB/AOF on/off)**와는 별개로, 복제를 위한 전용 메커니즘이며, "마스터의 AOF 파일을 읽어서 맞추는" 식으로 동작하지 않는다.

## AOF 활성화와 레플리카의 관계

- 공식 replication 문서에는 “AOF 파일로 재시작된 레플리카는 partial resync(부분 동기화)를 할 수 없고, RDB 기반으로 재시작해야 부분 동기화가 가능하다”는 문장이 있다.
- 이 문맥에서도 AOF는 **“해당 인스턴스가 재시작할 때 자기 상태를 복구하는 용도”**일 뿐, 레플리카가 마스터와 동기화할 때 쓰는 데이터 소스는 RDB/replication stream이며 AOF가 아니다.

정리하면, **클러스터든 단순 마스터–레플리카든, 읽기 노드 추가/동기화는 항상 복제 프로토콜(RDB 전송 + 스트림)로 이루어지고, 마스터의 AOF를 직접 읽어서 맞추는 경우는 없다.**  
AOF가 너무 커지면 Redis가 **AOF rewrite를 수행하면서 메모리 스냅샷을 RDB 포맷으로 preamble에 쓰고, 그 이후 연산만 tail AOF로 붙이는 구조**다.  

## AOF가 갱신(리라이트)되는 시점

- Redis는 AOF 파일이 “너무 커졌다”고 판단하면 **백그라운드에서 자동으로 AOF rewrite를 수행**한다.
- 자동 트리거 기준은 `auto-aof-rewrite-percentage`와 `auto-aof-rewrite-min-size` 설정으로 제어되며, 기본값으로는 “직전 rewrite 이후 파일 크기 대비 N% 이상 증가 + 최소 크기 이상”일 때 rewrite를 건다.
- 수동으로는 `BGREWRITEAOF` 명령을 호출하면 언제든지 rewrite를 시작할 수 있다.

## rewrite 시 RDB preamble + AOF tail 구조

- 공식 persistence 문서에 따르면, Redis는 rewrite 시 **기존 AOF를 읽어 재구성하는 것이 아니라, 메모리에 있는 현재 데이터셋으로부터 “최소 명령 집합”을 새 AOF 임시 파일에 쓴다.**
- `aof-use-rdb-preamble yes`가 켜져 있으면, 이 “최소 명령 집합”을 **RDB 포맷 스냅샷(preamble)**으로 기록하고, rewrite 도중에 새로 들어온 쓰기들은 별도 버퍼에 쌓았다가 rewrite가 끝난 후 **AOF tail 형태로 뒤에 이어붙인다.**
- 그 다음, 임시 AOF 파일을 fsync한 뒤 기존 AOF와 **원자적으로 교체(rename)**해서, 이후에는 새 AOF에만 append한다.

> 자세한 흐름은 아래와 같다.  
> 1. 레디스 인스턴스는 fork를 이용해 자식 프로세스를 생성. 생성된 자식 프로세스는 레디스 메모리의 데이터를 읽어와 신규로 생성한 임시 파일에 저장한다.
> 2. 백그라운드로 1번 과정이 진행되는 동안 레디스 메모리의 데이터가 변경된 내역은 신규 AOF 파일에 저장된다.
> 3. 1번의 AOF 재구성이 끝나면 임시 매니페스트 파일을 생성한 뒤, 변경된 버전으로 매니페스트 파일 내용을 업데이트한다.
> 4. 생성된 임시 매니페스트 파일로 기존 매니페스트 파일을 덮어 씌운 뒤, 이전 버전의 AOF, RDB 파일들을 삭제한다.

## 네가 예로 든 상황과 연결

- “AOF가 너무 많이 쌓인 경우 → RDB도 다시 스냅샷 뜨고 → 그 이후 연산만 AOF에 추가”라는 설명은 **공식 문서 기준으로 보면 바로 이 AOF rewrite + RDB preamble 동작을 직관적으로 표현한 것과 같다.**
- 다만 구현 관점에서 보면 “먼저 RDB를 따로 파일로 떴다 다시 쓰는 것”이라기보다, **rewrite용 child 프로세스가 현재 메모리 상태를 RDB 포맷/혹은 압축된 AOF 명령들로 새 파일에 쓰고, 이후 연산만 tail로 붙이는 흐름**이라고 이해하면 된다.


# 레디스 클러스터 모드

**1. 풀메시 vs Gossip 알고리즘**
- **풀메시**: 모든 노드가 서로 직접 연결되는 네트워크 구조(물리적 연결망)
- **Gossip 알고리즘**: 노드 상태를 주기적으로 전파하는 정보전파 방식(알고리즘)
- **Redis Cluster**: 풀메시 네트워크 위에서 Gossip 프로토콜을 사용해 장애 감지 및 상태 동기화

***

**2. Redis Cluster의 역할 구분**
- **모든 노드가 동일 책임이 아님**
- **마스터**: 데이터 저장/분산, 쓰기/읽기 주요 책임
- **레플리카**: 마스터 데이터 복제, 장애 시 자동 승격(failover)  
- 클러스터 구성상 현재 데이터의 소유와 복제 역할이 분리되어 있음

***

**3. 클러스터 구조 명칭**
- Redis Cluster는 **마스터리스(masterless)가 아니고**
- **마스터-레플리카(Master-Replica) 구조** 또는 마스터 기반 분산 클러스터라고 부름

***

**4. 마스터리스 vs 마스터 기반 클러스터 장단점**
|              | 마스터 기반             | 마스터리스            |
|--------------|------------------------|----------------------|
| **일관성**     | 강한 일관성 (Strong)    | 최종 일관성(Eventual) |
| **가용성**     | 레플리카로 빠른 장애복구 | 노드 장애에도 서비스 지속|
| **확장성**     | 샤드 추가, 다소 번거로움 | 노드 추가 쉽고 자동분산 |
| **복잡도**     | 상대적 단순             | 충돌/합의 복잡         |

***

**5. 마스터리스 클러스터의 쓰기 처리 방식**
- **모든 노드가 동등하게 쓰기 요청을 받음**
- Coordinator(처음 받은 노드)가 책임노드(복제노드 집합)에 분산/복제
- 해시/파티셔닝 기반으로 자동 분산됨
- 일관성-가용성 균형(QUORUM 등) 설정 가능  
- 마스터 선정 과정 없이 각 노드가 독립적으로 처리(자동화/분산)

***

이렇게, 분산 시스템에서 **클러스터 구조, 책임 분담, 장애복구, 데이터 일관성**의 차이와 설계·운영상의 주요 포인트를 비교·정리해 보았습니다.

# 비동기 복제
Redis 클러스터에서 **비동기 복제(Asynchronous Replication)**란, 마스터에서 변경(쓰기, 삭제 등)이 발생하면 그 내용을 레플리카 노드에 "즉시 전파(push)"하지만, 마스터는 레플리카의 반영 결과를 기다리지 않고, 바로 클라이언트에게 응답합니다. 이 방식의 동작 흐름을 좀 더 자세히 설명하면 다음과 같습니다.

### 비동기 복제의 동작 순서와 특징

- **명령 동작 프로세스**
  - 클라이언트가 마스터에 데이터를 쓰면, 마스터는 즉시 데이터셋을 변경하고 해당 변경 명령을 레플리카에 "스트림"으로 전송합니다.
  - *명령 전송*은 네트워크 소켓 버퍼를 통해 실시간으로 매우 빠르게 전송되지만, 네트워크 대역폭, 레플리카 성능 등에 따라 "전파 지연(replication lag)"이 발생할 수 있습니다.

- **마스터의 클라이언트 응답 시점**
  - 마스터는 **명령을 레플리카에 보낸 직후, 레플리카가 실제로 반영했는지 확인하지 않고 바로 클라이언트에 성공 응답**을 반환합니다.
  - 이 때문에 "레플리카가 동기화된 상태 보장"이 아니며, 마스터에서 바로 장애가 발생하면 일부 변경 사항이 레플리카에 반영되지 않을 수 있습니다.

- **레플리카의 반영 로직**
  - 레플리카는 마스터가 보내는 명령 스트림을 그대로 받아서 자신에게 적용합니다.
  - 레플리카가 느릴 경우, 소켓 버퍼에 명령이 쌓이고, 너무 심각한 지연이 발생하면 Redis는 해당 레플리카를 일시적으로 연결 해제시킵니다.
  - 파라미터 `min-replicas-max-lag` 값으로 허용되는 최대 지연 시간을 설정해, 지정된 값 이상의 지연이 발생하면 마스터는 쓰기 요청을 거부할 수도 있습니다.

- **복제 지연(replication lag)**
  - "복제 지연"은 보통 밀리초~수초 단위이지만, 네트워크 불안정이나 레플리카 장애 시 더 길어질 수 있습니다.
  - `WAIT` 명령을 사용하면 특정 쓰기 명령이 최소 N개의 레플리카에 "반영될 때까지" 대기할 수 있으나, 이것이 일반적 시스템의 동작은 아닙니다.


**비동기 복제의 실제 데이터 흐름 예시**
1. 마스터에서 `SET k v` 실행 시, 마스터는 자신의 메모리에 즉시 반영.
2. 마스터는 해당 명령을 모든 레플리카 노드로 즉시 "푸시(push)".
3. 레플리카는 수신 후 자기 데이터셋에 반영.
4. 마스터는 레플리카의 반영 결과와 상관없이 바로 클라이언트에 OK 응답.
5. 네트워크가 느리거나, 레플리카 리소스가 부족하다면 복제 지연 발생 ⇒ 일시적으로 레플리카의 데이터가 최신이 아니게 됨.

### 정리

- Redis의 비동기 복제는 **마스터가 레플리카의 반영을 기다리지 않고 바로 응답**함으로써 "쓰기 트랜잭션 속도가 매우 빠름"과 "복제 지연 가능성"이 공존합니다.
- 실시간 데이터 일관성이 반드시 필요한 경우, 마스터 노드에서 직접 읽거나, `WAIT` 등의 옵션을 활용해야 합니다.
- 시스템 장애 시, 복제 지연 구간의 데이터 손실 위험이 있습니다.
- redis.conf를 전혀 건드리지 않아도, 빌트인 기본값은 “1시간 1번 / 5분 100번 / 60초 10000번” 조건으로 RDB 스냅샷이 발생하도록 되어 있다.
*이 구조가 만든 트레이드오프: 고성능과 낮은 일관성(Consistency) 사이의 절충점입니다*.

# RESP의 기본 개념
RESP 프로토콜 형식이란, **Redis 클라이언트와 서버가 TCP 위에서 통신할 때 사용하는 “Redis 전용 직렬화 프로토콜(메시지 포맷)”**을 말한다.
- RESP는 “REdis Serialization Protocol”의 약자로, 문자열·정수·배열 같은 타입을 **텍스트 기반 형식으로 직렬화해서 송수신하는 규칙**이다.
- 클라이언트는 명령과 인자를 **배열(Array) 형태의 Bulk String들**로 인코딩해서 보내고, 서버는 명령에 따라 Simple String, Error, Integer, Bulk String, Array 등의 RESP 타입으로 응답한다.

# 무지목록

1. list의 블로킹은 BRPOP, BLPOP으로 여러 개의 큐에 대한 데이터 감지를 하도록 명령할 수 있는데 레디스에 성능적으로 영항은 없는것인가?
2. 카프카의 파티션을 여러 개 분리해서 사용하지 않는다면 레디스 stream을 선택하는 것이 좋을까?
