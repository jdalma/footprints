
# **프록시 패턴**

프록시 패턴의 기본 기능은 **프록시 클래스를 생성하여 원본 클래스와 관련이 없는 기능을 추가하는 것** 이다.  
1. 주요 비즈니스와 관련 없는 요구 사항의 개발에 활용될 수 있다.
   - 모니터링, 통계, 인증, 트래픽 제한, 트랜잭션, 멱등성, 로깅과 같이 주요 비즈니스와 관련없는 요구 사항을 개발하는데 적합하다.
2. RPC에서 프록시 패턴을 적용할 수 있다.
   - RPC 프레임워크는 프록시 패턴의 응용 프로그램이다.
3. 캐시에 프록시 패턴을 적용할 수 있다.


## 인터페이스 기반의 프록시 패턴

프록시 패턴은 원본 클래스를 변경하지 않은 상태로 **프록시 클래스**를 도입하여 원본 클래스와 관련 없는 새로운 기능을 추가하는 것이다.  

```kotlin
class UserController(
  private val metricsCollector: MetricsCollector
) {
  
  fun login(tel: String, password: String) : UserVO {
    // 핵심 외 기능 : 실행 시작 시간 기록

    // 핵심 : 비즈니스 로직

    // 핵심 외 기능 : 실행 결과 시간 계산 및 Metric전달
  }
}
```

위의 예제를 보면 **성능 통계 코드가 비즈니스 코드를 침범해 밀접하게 결합되어 있다.**  
이후 `MetricsCollector`가 변경되어야 한다면 핵심 비즈니스 로직에도 수정이 일어날 확률이 높다.  
  
이때 비즈니스 코드에서 성능 통계 코드를 분리하기 위해 프록시 패턴이 유용하게 사용될 수 있다.  

```kotlin
interface IUserController {
    fun login(tel: String, password: String) : UserVO
}

class UserController: IUserController {
    override fun login(tel: String, password: String): UserVO {
        // 핵심 로직
    }
}

class UserControllerProxy (
    private val target: IUserController,
    private val metricsCollector: MetricsCollector
) : IUserController {
    override fun login(tel: String, password: String): UserVO {
        // 부가 기능
        target.login(tel, password)
        // 부가 기능
    }
}
```

위의 코드에서 클라이언트 코드는 `IUserController` 타입에 의존하지만 실제 구현체를 `UserControllerProxy`로 주입하게 되면 클라이언트 코드는 프록시의 기능 존재를 알아차릴 수 없다.  

## 상속 기반의 프록시 패턴

인터페이스 기반의 프록시 패턴에서는 원본 클래스와 프록시 클래스가 동일한 인터페이스를 구현했다.  
하지만 원본 클래스가 외부 라이브러리의 클래스일 뿐만 아니라 인터페이스를 정의하지 않고 있어서 클래스를 직접 수정할 수 없는 경우에 적합하다.  

```kotlin
open class UserController {
    open fun login(tel: String, password: String): UserVO {
        // 핵심 로직
    }
}

class UserControllerProxy (
    private val metricsCollector: MetricsCollector
) : UserController() {
    override fun login(tel: String, password: String): UserVO {
        // 부가 기능
        super.login(tel, password)
        // 부가 기능
    }
}
```

## 리플렉션 기반의 동적 프록시

앞의 예제는 프록시 클래스가 원본 클래스의 모든 메서드를 다시 구현해야하기 때문에 번거롭다.  
그리고 프록시 클래스가 늘어날수록 복잡도가 커진다.  
  
이 문제를 해결할 수 있는 방법은 **동적 프록시** 를 사용하여 각 원본 클래스에 대한 프록시 클래스를 미리 작성하는 대신, `코드를 실행하는 도중에 원본 클래스에 대한 프록시 클래스를 동적으로 생성하고, 코드 내의 원본 클래스를 프록시 클래스로 대체하는 것`을 말한다.  
통계적 성능이 필요한 클래스를 위해 프록시 클래스를 동적으로 생성해주는 `MetricsControllerProxy` 동적 프록시 클래스를 확인해보자.

```kotlin
fun main(args: Array<String>) {
    val proxy = MetricsControllerProxy()
    val controller: IUserController = proxy.createProxy(UserController()) as IUserController
    controller.hello("first")
    controller.bye("second")
}

interface IUserController {
    fun hello(name: String) : String
    fun bye(name: String) : String
}

class UserController : IUserController {
    override fun hello(name: String) = "hello $name"
    override fun bye(name: String) = "bye $name"
}

class MetricsControllerProxy {

    fun createProxy(proxiedObject: Any) : Any {
        val interfaces : Array<Class<*>> = proxiedObject.javaClass.interfaces
        val dynamicProxyHandler = DynamicProxyHandler(proxiedObject)
        return newProxyInstance(
            proxiedObject.javaClass.classLoader,
            interfaces,
            dynamicProxyHandler
        )
    }

    private class DynamicProxyHandler (
        private val proxiedObject: Any
    ) : InvocationHandler {
        override fun invoke(proxy: Any, method: Method, args: Array<out Any>): Any {
            val startTimeStamp = System.currentTimeMillis()

            val result = method.invoke(proxiedObject, args[0])

            val endTimeStamp = System.currentTimeMillis()
            val responseTime = endTimeStamp - startTimeStamp

            // responseTime Metric 기록
            println("response time : $responseTime, result : $result")

            return result
        }
    }
}
```

***

# **[데코레이터 패턴](https://github.com/jdalma/design-patterns/commit/9537c45bc4b9c53e0f9af0d4bd48c7503998fc2d)**

## 패턴 소개

**기존 코드를 변경하지 않고 부가 기능을 추가하는 패턴**   
Java의 `IO 클래스 라이브러리`가 가지고 있는 기본 설계 사상을 분석하여 데코레이터 패턴을 설명할 수 있다.  

```java
InputStream bin = new BufferedInputStream(new FileInputStream("text.txt"))
```

![](imgs/structureRelated/inputStream.png)

이렇게 사용할 바에는 **FileInputStream** 클래스를 확장하여 캐싱을 지원하는 **BufferedFileInputStream** 클래스를 설계하는 것이 더 낫지 않을까?  
아래와 같이 말이다.

```java
InputStream bin = new BufferedFileInputStream("text.txt")
```

상속 구조가 비교적으로 간단하면 문제가 되지 않지만, InputStream 클래스에 수많은 하위 클래스가 존재하기 때문에, 모든 하위 클래스에 버퍼 기반의 읽기를 추가하게 되면 `Buffered`로 시작하는 수많은 하위의 하위 클래스를 파생시켜야 한다. [Hierarchy For Package java.io](https://docs.oracle.com/javase/8/docs/api/java/io/package-tree.html)  
추가로 기본 데이터 유형에 따라 데이터 캐싱과 읽기를 모두 지원하는 클래스가 필요하다면 다시 **BufferedData** 로 시작하는 수많은 하위 클래스를 만들어야 할 것이다.  
이러한 이유로 인해 **Java IO 클래스 라이브러리가 너무 커질 수 있기 때문에 상속이 아닌 `합성`을 사용했다.**  
  
그럼 데코레이터 패턴은 단순히 상속을 합성으로 대체하는 데 사용되는 패턴이라고 생각할 수도 있지만, 그렇지 않다.  
Java IO 클래스 라이브러리 설계에서 데커레이터 패턴이 사용된 이유는 합성 관계와 아래와 같은 차이점이 있다.  

<h3>데코레이터 클래스가 원본 클래스와 동일한 상위 클래스를 상속하기 때문에, 원본 클래스 내에 여러 개의 데코레이터 클래스를 중첩할 수 있다는 점</h3>

`FileInputStream`클래스에 대해 두 개의 데코레이터 클래스인 `Buffered`와 `Data` InputStream을 중첩하여 **기본 데이터 유형에 따라 버퍼 기반의 읽기와 데이터 읽기를 모두 지원하고 있다는 것을 알 수 있다.**  

```java
FileInputStream fileInputStream = new FileInputStream("test.txt");
BufferedInputStream bufferedInputStream = new BufferedInputStream(fileInputStream);
DataInputStream dataInputStream = new DataInputStream(bufferedInputStream);
```

<h3>데코레이터 클래스의 기능이 원본 클래스의 기능을 향상시키는 점</h3>

프록시 패턴과 데코레이터 패턴은 매우 유사하지만, **프록시 패턴의 프록시 클래스는 원본 클래스와 관련이 없는 기능을 추가하는 반면, 데코레이터 패턴의 데코레이터 클래스는 원본 클래스와 관련이 깊은 기능을 추가한다.**  

```java
public interface IA {
    void f();
}

public class A implements IA {
    public void f() { ... }
}

public class ADecorator implements IA {
    private IA a;
    public ADecorator(IA a) {
        this.a = a;
    }

    public void f() {
        // 기능 향상 코드
        a.f();
        // 기능 향상 코드
    }
}
```

**데코레이터 클래스는 개선해야 하는 메서드만 구현하고, 다른 메서드는 데코레이터 상위 클래스의 기본 구현을 상속한다.**  
핵심은 **원본 클래스에 `향샹된 기능을 추가`하는 것이며, 이는 데코레이터 패턴 사용 여부를 판단하는 중요한 기준이기도 하다.**  

## 적용 예제

1. `InputStream`, `OutputStream`, `Reader`, `Writer`의 생성자를 활용한 랩퍼
2. `Collections`이 제공하는 데코레이터 메소드
   - `Collections.checkedXXX()`
   - `Collections.synchronizedXXX()`
   - `Collections.unmodifiableXXX()`
3. 웹플럭스 `ServerHttpRequestDecorator`, `ServerHttpResponseDecorator`
4. 빈 설정 데코레이터 `BeanDefinitionDecorator`

***

# **[어댑터 패턴](https://github.com/jdalma/design-patterns/tree/master/src/main/java/me/whiteship/designpatterns/_02_structural_patterns/_06_adapter)**

## 패턴 소개

- 클래스 어댑터와 객체 어댑터에 대해 살펴보고, 다섯 가지 응용 방법에 대해 알아보자 // TODO
- **기존 코드를 클라이언트가 사용하는 인터페이스의 구현체로 바꿔주는 패턴**
  - *클라이언트가 사용하는 인터페이스를 따르지 않는 기존 코드를 재사용할 수 있게 해준다*

![](imgs/structureRelated/adapterDiagram.png)

![](imgs/structureRelated/adapter1.png)

- **UserDetail** , **UserDetailsService** 인터페이스가 `Target`에 해당한다
- **Account** 와 **AccountService**가 `Adaptee`에 해당한다
- 📌
  - 어떻게 **UserDetailsService**와 **AccountService**를 연결할 것 인가?
  - 어떻게 **Account**와 **UserDetails**를 연결할 것인가?

***

# **브리지 패턴**

// TODO